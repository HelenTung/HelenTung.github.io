[{"categories":["Code","C"],"content":"ココの领悟～","date":"2022-06-04","objectID":"/posts/coding/c_point/","tags":["C","Point"],"title":"C指针与多级指针","uri":"/posts/coding/c_point/"},{"categories":["Code","C"],"content":"指针与多级指针 什么是指针？指针是变量，确切的讲是储存地址的一种变量，全称应当是指针变量而非指针，以下是定义整形指针变量的代码。 #include\u003cstdio.h\u003e int main() { int *p = NULL; int m = 10; int *q = \u0026m; p = \u0026m; printf(\"%d %d\\n\",*q,*p);//p与q地址相同 return 0;//此时指针p q等效 } ","date":"2022-06-04","objectID":"/posts/coding/c_point/:1:0","tags":["C","Point"],"title":"C指针与多级指针","uri":"/posts/coding/c_point/"},{"categories":["Code","C"],"content":"一级指针 一级指针是指指向某个变量并储存其地址的指针变量，或者是它本身就是地址，指针和地址其实是同样的意思。 注意指针本身就是一种变量，它本身也开辟了一块空间来存储它本身，指针变量本身也有地址，这就引出了多级指针，在外文中没有多级指针的说法，取而代之的则是pointer to pointer。 一级指针的定义 #include\u003cstdio.h\u003e int *p = NULL; int m = 10; p = \u0026m;//指针变量取得是地址，所以要加上取地址符 printf(\"%d\\n\",*p);//10 return 0; ","date":"2022-06-04","objectID":"/posts/coding/c_point/:1:1","tags":["C","Point"],"title":"C指针与多级指针","uri":"/posts/coding/c_point/"},{"categories":["Code","C"],"content":"多级指针（重点） 本质上讲多级指针和一级指针并没有区别，储存的都是地址，但多级指针是指向指针的指针，如下例代码： //此处p的地址是0x7fffffffdd54 *p 0xffffdd540000000a //q是0x7fffffffdd58 *q是0x7fffffffdd54，**q是0xffffdd540000000a int main() { int **p =NULL; int ***q = NULL; int m = 10; p = \u0026m; //q= \u0026m; //printf(\"%d %d\\n\",*p,*q); //几级指针取地址就几级指针解引用 q = \u0026p; printf(\"%d %d\\n\",*p,**q);//10 10 return 0; } 指针变量p是一个二级指针，指向的是整形变量m = 10，他用了p去存储这个整形变量的地址，也即是p的地址0xffffdd540000000a，是这个整形变量的地址，此时我们再用另外一个多级指针q来指向这个指针p，可以看到在q中出现了三个地址，这其中有两个地址是相同的，也即是指针p本身的地址0x7fffffffdd54也被指针储存了，除此之外，还储存了*p所指向的整形变量m的地址0xffffdd540000000a，另外，q本身也有地址 0x7fffffffdd58 我们来看看对应关系： p *p **p 0x7fffffffdd54 0xffffdd540000000a 并不储存地址 q *q **q ***q 0x7fffffffdd58 0x7fffffffdd54 0xffffdd540000000a 并不存储地址 二级指针p直接指向整形变量的话，实际上他是取了一级指针p指向整形变量而非二级指针直接指向整形变量m,而三级指针q在指向二级指针p时，则在本身地址的基础上全面继承了二级指针p的地址，对应关系如上表。 按照gcc编译来说多级指针来说是不能直接指向整形变量m的，会报一个warning,提示间隔级别int *和int ** 不同，有些编译器可能不出现警告，这也是正常的） 以下是在上面基础上修改过的代码： int main() { int *t = NULL; int **p =NULL; int ***q = NULL; int m = 10; t = \u0026m; p = \u0026t; //q= \u0026m; //printf(\"%d %d\\n\",*p,*q); //几级指针取地址就几级指针解引用 q = \u0026p; printf(\"%d %d\\n\",**p,***q); return 0; } 断点调试，他们的地址如下： t : 0x7fffffffdd4c *t : 10 p : 0x7fffffffdd50 *p : 0x7fffffffdd4c **p : 10 q : 0x7fffffffdd58 *q : 0x7fffffffdd50 **q : 0x7fffffffdd4c ***q : 10 思考：为什么这里存在一个数值10？而在上方代码中则不存在。 对比发现，上方的结论是正确的，以上就是指针与多级指针的内容。 ","date":"2022-06-04","objectID":"/posts/coding/c_point/:1:2","tags":["C","Point"],"title":"C指针与多级指针","uri":"/posts/coding/c_point/"},{"categories":["network"],"content":"ココの～网络","date":"2022-04-04","objectID":"/posts/thinking/wireshark_use/","tags":["network","wireshark"],"title":"Wireshark的使用","uri":"/posts/thinking/wireshark_use/"},{"categories":["network"],"content":"Wireshark的使用与常见错误 wireshark的主要作用是为了诊断网络出现的问题，大致上比较重要的部分是过滤器与结果的表达，这两点是比较重要的，比如在过滤器中对协议进行选择，排除无关协议的影响，比如结果的如何呈现会更加直观，对tcp来讲，选择tcp流形图会不会比流量图更好。 以下是一张wireshark主界面图： 注意，本机系统为archlinux,启动时要使用管理员身份。 ","date":"2022-04-04","objectID":"/posts/thinking/wireshark_use/:1:0","tags":["network","wireshark"],"title":"Wireshark的使用","uri":"/posts/thinking/wireshark_use/"},{"categories":["network"],"content":"过滤器 协议过滤 例如：ARP(ip转mac协议) 注意不区分大小写 协议参数过滤 例如这里选择了IPv4协议，对源地址进行了筛选ip.src_host 连接词的使用 类同于C语言，\u0026\u0026(与)，||(或)， !(非)，除此之外，还有and,or之类，与前一致。 ! 的使用 \u0026\u0026的使用 注意连接词可以同时使用 ","date":"2022-04-04","objectID":"/posts/thinking/wireshark_use/:1:1","tags":["network","wireshark"],"title":"Wireshark的使用","uri":"/posts/thinking/wireshark_use/"},{"categories":["network"],"content":"结果输出 ip.src_host == 43.129.76.227 \u0026\u0026 ip.dst_host == 192.168.88.153主机之间的流量图 ip.src_host == 43.129.76.227 \u0026\u0026 ip.dst_host == 192.168.88.153 主机之间的通信，数据包流量图如图所示。 注意：捕获选项中的混杂器选项代表了主机是否丢弃非目的地址的包，可以打开此选项以此来查看子网流通性或关闭此选项来减少捕获包的数量，从而减少分析难度 ","date":"2022-04-04","objectID":"/posts/thinking/wireshark_use/:1:2","tags":["network","wireshark"],"title":"Wireshark的使用","uri":"/posts/thinking/wireshark_use/"}]