[{"categories":["Go","Code"],"content":"ココのcoding","date":"2022-07-15","objectID":"/posts/coding/go%E5%B9%B6%E5%8F%91%E7%9A%84%E4%B8%89%E7%A7%8D%E6%A8%A1%E5%BC%8F/","tags":["Go","Code"],"title":"go并发的三种模式","uri":"/posts/coding/go%E5%B9%B6%E5%8F%91%E7%9A%84%E4%B8%89%E7%A7%8D%E6%A8%A1%E5%BC%8F/"},{"categories":["Go","Code"],"content":"并发的三种模式 runner.go 主要为切片放置任务函数 package runner import ( \"errors\" \"os\" \"os/signal\" \"time\" ) type Runner struct { // interrupt 通道报告从操作系统发送的信号 interrupt chan os.Signal //complete通道报告处理任务已经完成 complete chan error //timeout 报告任务超时，注意方向 timeout \u003c-chan time.Time //tasks持有依次执行的任务函数 tasks []func(int) } //任务超时返回 var ErrTimeout = errors.New(\"received timeout\") //任务中断返回 var ErrInterrupt = errors.New(\"received interrupt\") //New返回一个新的准备使用的runner、初始化操作 func New(d time.Duration) *Runner { return \u0026Runner{ interrupt: make(chan os.Signal, 1), complete: make(chan error), timeout: time.After(d), } } //Add函数添加任务到Runner上 func (r *Runner) Add(tasks ...func(int)) { r.tasks = append(r.tasks, tasks...) } //start执行任务，并监视管道 func (r *Runner) Start() error { //接受所有中断信号 signal.Notify(r.interrupt, os.Interrupt) //用不同的goroutine执行不同的任务 go func() { r.complete \u003c- r.run() }() select { //当任务完成的发出的信号 case err := \u003c-r.complete: return err //当任务超时的时发出的信号 case \u003c-r.timeout: return ErrTimeout } } func (r *Runner) run() error { for id, task := range r.tasks { //检测操作系统的中断信号 if r.gotInterrupt() { return ErrInterrupt } //执行已经在队列中的任务 task(id) } return nil } func (r *Runner) gotInterrupt() bool { select { //当中断时间被触发时的信号 case \u003c-r.interrupt: //停止接收后续信号 signal.Stop(r.interrupt) return true //继续正常运行 default: return false } } pool.go 主要有缓冲channel放置任务函数 package pool import ( \"errors\" \"log\" \"io\" \"sync\" ) //管理goroutine的pool type Pool struct{ m sync.Mutex resources chan io.Closer factory func()(io.Closer,error) closed bool } //pool已经关闭 var ErrPoolClosed = errors.New(\"Pool has been closed\") func New(fn func()(io.Closer,error),size uint)(*Pool,error){ if size \u003c= 0{ return nil,errors.New(\"size value too small\") } return \u0026Pool{ factory: fn, resources: make(chan io.Closer,size), },nil } //从池子获取资源 func (p *Pool)Acquire()(io.Closer,error){ select{ //检查是否存在空闲资源 case r,ok := \u003c- p.resources: log.Println(\"Acquire:\",\"Shared Resource\") if !ok { return nil,ErrPoolClosed } return r,nil //因为没有空闲资源，所以提供一个新资源 default: log.Println(\"Acquire:\",\"New Resource\") return p.factory() } } //将最后一个资源放回池子里面 func (p *Pool)Release(r io.Closer){ //保证可靠性 p.m.Lock() defer p.m.Unlock() //如果池子已经被关闭,则销毁资源 if p.closed { r.Close() return } select{ //将资源放入队列 case p.resources \u003c-r: log.Println(\"Releae:\",\"In Queue\") //队列已满，关闭资源 default: log.Println(\"Release:\",\"Closing\") r.Close() } } //让资源池停止工作，并且释放资源 func (p *Pool)Close(){ //保证操作安全性 p.m.Lock() defer p.m.Unlock() //如果pool已经被关闭 if p.closed { return } //关闭池子 p.closed = true //清空管道资源之前要关闭管道，不然会发生死锁 close(p.resources) for r := range p.resources { r.Close() } } work.go 主要为无缓冲放置任务函数 package work import \"sync\" type Worker interface { Task() } type Pool struct { work chan Worker wg sync.WaitGroup } func New(maxGoroutine int) *Pool { p := Pool{ work: make(chan Worker), } p.wg.Add(maxGoroutine) for i := 0; i \u003c maxGoroutine; i++ { go func() { for w := range p.work { w.Task() } p.wg.Done() }() } return \u0026p } func (p *Pool) Run(w Worker) { p.work \u003c- w } func (p *Pool) Shutdown() { close(p.work) p.wg.Wait() } ","date":"2022-07-15","objectID":"/posts/coding/go%E5%B9%B6%E5%8F%91%E7%9A%84%E4%B8%89%E7%A7%8D%E6%A8%A1%E5%BC%8F/:0:1","tags":["Go","Code"],"title":"go并发的三种模式","uri":"/posts/coding/go%E5%B9%B6%E5%8F%91%E7%9A%84%E4%B8%89%E7%A7%8D%E6%A8%A1%E5%BC%8F/"},{"categories":["算法"],"content":"ココの~rsa思考","date":"2022-07-04","objectID":"/posts/thinking/rsa%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/","tags":["算法","加密","RSA"],"title":"RSA加密算法","uri":"/posts/thinking/rsa%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/"},{"categories":["算法"],"content":"非对称加密-RSA算法 ","date":"2022-07-04","objectID":"/posts/thinking/rsa%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/:1:0","tags":["算法","加密","RSA"],"title":"RSA加密算法","uri":"/posts/thinking/rsa%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/"},{"categories":["算法"],"content":"概念 加密和解密可以使用不同的规则，只要这两种规则之间存在某种对应关系即可，这样就避免了直接传递密钥。这种新的加密模式被称为\"非对称加密算法\"。 对称加密： 甲方选择某一种加密规则，对信息进行加密； 乙方使用同一种规则，对信息进行解密。 非对称加密： 乙方生成两把密钥（公钥和私钥）。公钥是公开的，任何人都可以获得，私钥则是保密的。 甲方获取乙方的公钥，然后用它对信息加密。 乙方得到加密后的信息，用私钥解密。 常见的非对称加密算法有RSA算法、ECC椭圆曲线算法等等 ","date":"2022-07-04","objectID":"/posts/thinking/rsa%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/:1:1","tags":["算法","加密","RSA"],"title":"RSA加密算法","uri":"/posts/thinking/rsa%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/"},{"categories":["算法"],"content":"前置知识 RSA算法与欧拉函数存在一定关系，本篇不对欧拉函数进行讨论，仅仅了解计算即可 互质关系： 一个数是质数，另一个数只要不是前者的倍数，两者就构成互质关系，比如3和10。 如果两个数之中，较大的那个数是质数，则两者构成互质关系，比如97和57。 1和任意一个自然数是都是互质关系，比如1和99。 p是大于1的整数，则p和p-1构成互质关系，比如57和56。 p是大于1的奇数，则p和p-2构成互质关系，比如17和15。 欧拉函数计算： 概念：任意给定正整数n，请问在小于等于n的正整数之中，有多少个与n构成互质关系，计算这个值的方法就叫做欧拉函数，以φ(n)表示。例如、在1到7之中，与7形成互质关系的是1、2、3、4、5、6，在1到9之中，与9形成互质关系的是1、2、4、5、7、8。 公式：m^φ(n) ≡ 1 (mod n) 若 p * q = n 且pq也为质数的情况下，则有φ(n) = (p-1) * (q-1)。也即是得出结论：两个质数之积的欧拉函数的值等于两个数的欧拉函数之值的乘积。利用到了互质关系中的第三点，任何数与质数都是互质关系。 模反元素： 模反元素：如果两个正整数a和n互质，那么一定可以找到整数b，使得 ab-1 被n整除，或者说ab被n除的余数是1，b就叫做a的\"模反元素\"。此处的ab即为RSA算法中提到的\"私钥\"与\"公钥\"。公式有：ab≡ 1 (mod n) 举例有：3和11互质，那么3的模反元素就是4，因为3*4-1刚好可以被11整除,所以4和3互为模反元素，又如5和34互质，那么5和7就互为模反元素，也是5*7-1=34 注意互质关系不一定两个数都是质数，具体可以参考5和34,7和12等等。 ","date":"2022-07-04","objectID":"/posts/thinking/rsa%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/:1:2","tags":["算法","加密","RSA"],"title":"RSA加密算法","uri":"/posts/thinking/rsa%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/"},{"categories":["算法"],"content":"RSA加密 加密过程： 第一步：随机生成质数p与q、得出n = p * q 第二步：计算n的欧拉函数值，使用欧拉函数公式即可：φ(n) = (p-1) * (q-1) 第三步：在1与φ(n)之间随机生成整数e，条件是1\u003c e \u003c φ(n)，且e与φ(n) 互质。 第四步：计算e对于φ(n)的模反元素d，带入公式有ed≡ 1 (mod n)，等价于 ed - 1 = kφ(n)、于是，找到模反元素d 第五步：将n和e封装成公钥，n和d封装成私钥。 举例分析：若p = 53、q= 61、则 n = p*q = 3233、φ(n) = (p-1)*(q-1) = 3120、若随即选择e = 17、d = 2753。则私钥对为（3233,2753）、公钥对为（3233,17）。 可靠性分析：p、q、n、e、φ(n)、d是已经出现的数字、这六个数字之中，公钥用到了两个（n和e），其余四个数字都是不公开的。其中最关键的是d，因为n和d组成了私钥，一旦d泄漏，就等于私钥泄漏。那么在（n,e）公开的情况下，有没有可能推导出d,从而得出私钥（n,d）。 推导条件： ed≡1 (mod φ(n))。只有知道e和φ(n)，才能算出d。 φ(n)=(p-1)(q-1)。只有知道p和q，才能算出φ(n)。 n=pq。只有将n因数分解，才能算出p和q。 结论：如果n可以被因数分解，d就可以算出，也就意味着私钥被破解。 “对极大整数做因数分解的难度决定了RSA算法的可靠性。换言之，对一极大整数做因数分解愈困难，RSA算法愈可靠。假如有人找到一种快速因数分解的算法，那么RSA的可靠性就会极度下降。但找到这样的算法的可能性是非常小的。今天只有短的RSA密钥才可能被暴力破解。到2008年为止，世界上还没有任何可靠的攻击RSA算法的方式。只要密钥长度足够长，用RSA加密的信息实际上是不能被解破的。” 解密过程： 加密：m^e ≡ c (mod n)带入上述数字得出65^17 ≡ 2790 (mod 3233)，也即是2790为加密数字，65为真实数字 解密：c^d ≡ m (mod n)带入计算有2790^2753 ≡ 65 (mod 3233),解密得出65为真实数字 至此，“加密–解密\"的整个过程全部完成。 私钥解密的证明： 为什么用私钥解密，一定可以正确地得到m 由解密规则有：c^d ≡ m (mod n)、又由加密规则有：ｍ^e ≡ c (mod n)、则有：c = m^e - kn、将c代入要我们要证明的那个解密规则：(m^e - kn)^d ≡ m (mod n)等同于m^(ed) ≡ m (mod n)推出ed ≡ 1 (mod φ(n))、既有ed = hφ(n)+1、将ed代入ed ≡ 1 (mod φ(n))：m^(hφ(n)+1) ≡ m (mod n) 若mn互质：则有m^φ(n) ≡ 1 (mod n)、与上式连立有：(m^φ(n))^h × m ≡ m (mod n),原式得到证明。 若mn不为互质关系：以 m = kp为例，考虑到这时k与q必然互质，则根据欧拉定理，下面的式子成立：　(kp)^(q-1) ≡ 1 (mod q)、进一步得到:[(kp)^(q-1) ]^h(p-1) × kp ≡ kp (mod q)、既有(kp)ed ≡ kp (mod q)、改写为：(kp)^ed = tq + kp、这时t必然能被p整除，即 t=t’p、因为 m=kp，n=pq，所以m^ed ≡ m (mod n)、得证。 本文参考自：https://www.ruanyifeng.com/blog/2013/07/rsa_algorithm_part_two.html ","date":"2022-07-04","objectID":"/posts/thinking/rsa%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/:1:3","tags":["算法","加密","RSA"],"title":"RSA加密算法","uri":"/posts/thinking/rsa%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/"},{"categories":["Code","C"],"content":"ココの领悟～","date":"2022-06-04","objectID":"/posts/coding/c_point/","tags":["C","Point"],"title":"C指针与多级指针","uri":"/posts/coding/c_point/"},{"categories":["Code","C"],"content":"指针与多级指针 什么是指针？指针是变量，确切的讲是储存地址的一种变量，全称应当是指针变量而非指针，以下是定义整形指针变量的代码。 #include\u003cstdio.h\u003e int main() { int *p = NULL; int m = 10; int *q = \u0026m; p = \u0026m; printf(\"%d %d\\n\",*q,*p);//p与q地址相同 return 0;//此时指针p q等效 } ","date":"2022-06-04","objectID":"/posts/coding/c_point/:1:0","tags":["C","Point"],"title":"C指针与多级指针","uri":"/posts/coding/c_point/"},{"categories":["Code","C"],"content":"一级指针 一级指针是指指向某个变量并储存其地址的指针变量，或者是它本身就是地址，指针和地址其实是同样的意思。 注意指针本身就是一种变量，它本身也开辟了一块空间来存储它本身，指针变量本身也有地址，这就引出了多级指针，在外文中没有多级指针的说法，取而代之的则是pointer to pointer。 一级指针的定义 #include\u003cstdio.h\u003e int *p = NULL; int m = 10; p = \u0026m;//指针变量取得是地址，所以要加上取地址符 printf(\"%d\\n\",*p);//10 return 0; ","date":"2022-06-04","objectID":"/posts/coding/c_point/:1:1","tags":["C","Point"],"title":"C指针与多级指针","uri":"/posts/coding/c_point/"},{"categories":["Code","C"],"content":"多级指针（重点） 本质上讲多级指针和一级指针并没有区别，储存的都是地址，但多级指针是指向指针的指针，如下例代码： //此处p的地址是0x7fffffffdd54 *p 0xffffdd540000000a //q是0x7fffffffdd58 *q是0x7fffffffdd54，**q是0xffffdd540000000a int main() { int **p =NULL; int ***q = NULL; int m = 10; p = \u0026m; //q= \u0026m; //printf(\"%d %d\\n\",*p,*q); //几级指针取地址就几级指针解引用 q = \u0026p; printf(\"%d %d\\n\",*p,**q);//10 10 return 0; } 指针变量p是一个二级指针，指向的是整形变量m = 10，他用了p去存储这个整形变量的地址，也即是p的地址0xffffdd540000000a，是这个整形变量的地址，此时我们再用另外一个多级指针q来指向这个指针p，可以看到在q中出现了三个地址，这其中有两个地址是相同的，也即是指针p本身的地址0x7fffffffdd54也被指针储存了，除此之外，还储存了*p所指向的整形变量m的地址0xffffdd540000000a，另外，q本身也有地址 0x7fffffffdd58 我们来看看对应关系： p *p **p 0x7fffffffdd54 0xffffdd540000000a 并不储存地址 q *q **q ***q 0x7fffffffdd58 0x7fffffffdd54 0xffffdd540000000a 并不存储地址 二级指针p直接指向整形变量的话，实际上他是取了一级指针p指向整形变量而非二级指针直接指向整形变量m,而三级指针q在指向二级指针p时，则在本身地址的基础上全面继承了二级指针p的地址，对应关系如上表。 按照gcc编译来说多级指针来说是不能直接指向整形变量m的，会报一个warning,提示间隔级别int *和int ** 不同，有些编译器可能不出现警告，这也是正常的） 以下是在上面基础上修改过的代码： int main() { int *t = NULL; int **p =NULL; int ***q = NULL; int m = 10; t = \u0026m; p = \u0026t; //q= \u0026m; //printf(\"%d %d\\n\",*p,*q); //几级指针取地址就几级指针解引用 q = \u0026p; printf(\"%d %d\\n\",**p,***q); return 0; } 断点调试，他们的地址如下： t : 0x7fffffffdd4c *t : 10 p : 0x7fffffffdd50 *p : 0x7fffffffdd4c **p : 10 q : 0x7fffffffdd58 *q : 0x7fffffffdd50 **q : 0x7fffffffdd4c ***q : 10 思考：为什么这里存在一个数值10？而在上方代码中则不存在。 对比发现，上方的结论是正确的，以上就是指针与多级指针的内容。 ","date":"2022-06-04","objectID":"/posts/coding/c_point/:1:2","tags":["C","Point"],"title":"C指针与多级指针","uri":"/posts/coding/c_point/"},{"categories":["network"],"content":"ココの～网络","date":"2022-04-04","objectID":"/posts/thinking/wireshark_use/","tags":["network","wireshark"],"title":"Wireshark的使用","uri":"/posts/thinking/wireshark_use/"},{"categories":["network"],"content":"Wireshark的使用与常见错误 wireshark的主要作用是为了诊断网络出现的问题，大致上比较重要的部分是过滤器与结果的表达，这两点是比较重要的，比如在过滤器中对协议进行选择，排除无关协议的影响，比如结果的如何呈现会更加直观，对tcp来讲，选择tcp流形图会不会比流量图更好。 以下是一张wireshark主界面图： 注意，本机系统为archlinux,启动时要使用管理员身份。 ","date":"2022-04-04","objectID":"/posts/thinking/wireshark_use/:1:0","tags":["network","wireshark"],"title":"Wireshark的使用","uri":"/posts/thinking/wireshark_use/"},{"categories":["network"],"content":"过滤器 协议过滤 例如：ARP(ip转mac协议) 注意不区分大小写 协议参数过滤 例如这里选择了IPv4协议，对源地址进行了筛选ip.src_host 连接词的使用 类同于C语言，\u0026\u0026(与)，||(或)， !(非)，除此之外，还有and,or之类，与前一致。 ! 的使用 \u0026\u0026的使用 注意连接词可以同时使用 ","date":"2022-04-04","objectID":"/posts/thinking/wireshark_use/:1:1","tags":["network","wireshark"],"title":"Wireshark的使用","uri":"/posts/thinking/wireshark_use/"},{"categories":["network"],"content":"结果输出 ip.src_host == 43.129.76.227 \u0026\u0026 ip.dst_host == 192.168.88.153主机之间的流量图 ip.src_host == 43.129.76.227 \u0026\u0026 ip.dst_host == 192.168.88.153 主机之间的通信，数据包流量图如图所示。 注意：捕获选项中的混杂器选项代表了主机是否丢弃非目的地址的包，可以打开此选项以此来查看子网流通性或关闭此选项来减少捕获包的数量，从而减少分析难度 ","date":"2022-04-04","objectID":"/posts/thinking/wireshark_use/:1:2","tags":["network","wireshark"],"title":"Wireshark的使用","uri":"/posts/thinking/wireshark_use/"},{"categories":["操作系统"],"content":"ココの操作系统","date":"2021-03-04","objectID":"/posts/thinking/%E7%8E%B0%E4%BB%A3%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/","tags":["操作系统"],"title":"操作系统概念","uri":"/posts/thinking/%E7%8E%B0%E4%BB%A3%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/"},{"categories":["操作系统"],"content":"现代操作系统概念 进程 进程本质上是正在执行的一个程序。 与每个进程相关的是进程的地址空间（address space），这是从某个最小值的存储位置（通常是零）到某个最大值存储位置的列表。在这个地址空间中，进程可以进行读写。该地址空间中存放有可执行程序、程序的数据以及程序的堆栈。与每个进程相关的还有资源集，通常包括寄存器（含有程序计数器和堆栈指针）、打开文件的清单、突出的报警、有关进程清单，以及运行该程序所需要的所有其他信息。进程基本上是容纳运行一个程序所需要所有信息的容器。 若一个进程能够创建一个或多个进程（称为子进程），而且这些进程又可以创建子进程，则很容易得到进程树,合作完成某些作业的相关进程经常需要彼此通信以便同步它们的行为。这种通信称为进程间通信（interprocess communication） 可用的进程系统调用包括：申请更多的内存（或释放不再需要的内存）、等待一个子进程结束、用另一个程序覆盖该程序等。 系统管理器授权每个进程使用一个给定的UID标识（User IDentification）。每个被启动的进程都有一个启动该进程的用户UID。子进程拥有与父进程一样的UID。用户可以是某个组的成员，每个组也有一个GID标识（Group IDentification）。 地址空间 较复杂的操作系统允许在内存中同时运行多道程序。为了避免它们彼此互相干扰（包括操作系统），需要有某种保护机制。虽然这种机制必然是硬件形式的，但是它由操作系统掌控。上述的观点涉及对计算机主存的管理和保护。 另一种不同的但是同样重要并与存储器有关的内容，是管理进程的地址空间。通常，每个进程有一些可以使用的地址集合，典型值从0开始直到某个最大值。在最简单的情形下，一个进程可拥有的最大地址空间小于主存。在这种方式下，进程可以用满其地址空间，而且内存中也有足够的空间容纳该进程。 文件 为了提供保存文件的地方，大多数操作系统支持目录（directory）的概念，从而可把文件分类成组。 进程和文件层次都可以组织成树状结构，但这两种树状结构有不少不同之处。一般进程的树状结构层次不深（很少超过三层），而文件树状结构的层次常常多达四层、五层或更多层。进程树层次结构是暂时的，通常最多存在几分钟，而目录层次则可能存在数年之久。进程和文件在所有权及保护方面也是有区别的。典型地，只有父进程能控制和访问子进程，而在文件和目录中通常存在一种机制，使文件所有者之外的其他用户也可以访问该文件。 管道。管道（pipe）是一种虚文件，它可连接两个进程，如图1-16所示。如果进程A和B希望通过管道对话，它们必须提前设置该管道。当进程A想对进程B发送数据时，它把数据写到管道上，仿佛管道就是输出文件一样。进程B可以通过读该管道而得到数据，仿佛该管道就是一个输入文件一样。这样，在UNIX中两个进程之间的通信就很类似于普通文件的读写了。 输入输出 所有的计算机都有用来获取输入和产生输出的物理设备。有各种类型的输入和输出设备，包括键盘、显示器、打印机等。对这些设备的管理全然依靠操作系统。 所以，每个操作系统都有管理其I/O设备的I/O子系统。某些I/O软件是设备独立的，即这些I/O软件部分可以同样应用于许多或者全部的I/O设备上。I/O软件的其他部分，如设备驱动程序，是专门为特定的I/O设备设计的 保护 计算机中有大量的信息，用户经常希望对其进行保护，并保守秘密。这些信息可包括电子邮件、商业计划、退税等诸多内容。管理系统的安全性完全依靠操作系统 参考UNIX。UNIX操作系统通过对每个文件赋予一个9位的二进制保护代码，对UNIX中的文件实现保护。该保护代码有三个3位字段，一个用于所有者，一个用于所有者同组（用户被系统管理员划分成组）中的其他成员，而另一个用于其他人。每个字段中有一位用于读访问，一位用于写访问，一位用于执行访问。这些位就是知名的rwx位。 shell 操作系统是进行系统调用的代码 shell本身不是操作系统的一部分，但它体现了许多操作系统的特性，并很好地说明了系统调用的具体用法。shell同时也是终端用户与操作系统之间的界面，除非用户使用的是一个图形用户界面。有许多种类的shell，如sh、csh、ksh以及bash等 个体重复系统发育 大型内存 保护硬件 硬盘 虚拟内存 参考书籍：现代操作系统（原书第4版）_Modern Operating Systems (4th Edition) ([荷] Andrew S. Tanenbaum [荷] Herbert Bos) ","date":"2021-03-04","objectID":"/posts/thinking/%E7%8E%B0%E4%BB%A3%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/:0:1","tags":["操作系统"],"title":"操作系统概念","uri":"/posts/thinking/%E7%8E%B0%E4%BB%A3%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/"}]